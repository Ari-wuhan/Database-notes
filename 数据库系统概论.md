# 第一章 绪论

## 1.1数据库系统概论

### 数据库的四个基本概念

#### 数据

描述事物的符号记录称为数据。如文字、图像、音频、视频等多种表现形式

都可以经数字化后存入计算机

数据的含义称为数据等语义，数据与语义时不可分的

不同数据有不同的含义

如2001作为一个数字没有任何含义

但放在这样的记录里就有了含义：

比如描述一个人的姓名，性别，出生年：

（黎明，男，2001年）

在这里2001就表示出生年份

#### 数据库

数据库即数据的仓库

严格来讲，就是：

> 数据时时长期存储在计算机内、有组织的、可共享的大量数据的集合
>
> 数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易拓展性
>
> 并为各自用户共享

三个特点：永久存储、有组织、可共享

#### 数据库管理系统

数据库管理系统用来管理数据库，组织、存储数据，获取、维护数据

是介于用户与操作系统之间的一层数据库管理软件

是计算机的基础软件

> 主要功能：
>
> 1. 数据定义功能（DDL）
> 2. 数据组织、管理和存储
> 3. 数据操纵功能（DML）
> 4. 数据库的事务管理和运行管理
> 5. 数据库的建立和维护功能

#### 数据库系统

> 数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统

少不了数据库管理员的人为管理维护

### 数据管理技术的产生和发展

数据库的管理是指对数据进行分类、组织、编码、存储、检索和维护

是数据处理的中心问题

数据库管理技术经过了三个发展阶段：

1. 人工管理阶段

   ​	不共享，数据通过程序员来进行管理，完全依赖于程序

2. 文件系统管理阶段

   有了文件系统来进行管理，但是共享性很差

3. 数据库系统阶段

   通过数据库管理系统来进行管理，共享性高，冗余度小

   从文件系统到数据库管理系统标志着数据库管理系统的飞跃

### 数据库系统的特点

#### 1.数据结构化

>  数据库系统实现整体数据的结构化，这是数据库的主要特征之一

也是数据库系统与文件系统的本质区别

所谓整体结构化，是指数据不再仅仅面向一个应用程序，而是整个用户群体；数据之间时有联系的

#### 2.数据的共享性高、冗余度低且易拓展

>  数据共享可以解决数据冗余，节约存储空间

同时也避免了数据之间的不相容性和不一致性

使得数据库弹性大，容易扩充

#### 3.数据独立性高

数据独立性包括物理独立性和逻辑独立性

物理独立性是指

>  用户的应用程序与数据库中数据的物理存储时相互独立的

逻辑独立性是指

>  用户的应用程序与数据库的逻辑结构是相互独立的

#### 4.数据由数据库管理系统统一管理和控制

数据库的共享是并发的，会带来安全隐患

为此数据库管理系统必须提供以下数据控制功能：

> 数据库的安全保护:
>
> ​	//防止数据泄露和被破坏
>
> 数据库的完整性检查
>
> ​	//数据库的完整性是指数据的正确性、有效性和相容性
>
> 并发控制
>
> 数据库恢复

## 1.2数据模型

所谓数据模型，是对现实世界数据特征的抽象

数据模型，是数据库系统的核心和基础

### 两类数据模型

> 第一类是概念模型
>
> 第二类是逻辑模型和物理模型

>  概念模型是按照用户的观点来对数据和信息建模

即将现实世界抽象为信息世界后得到的模型

比如牛这一个实体，抽象后得到牛的汉子或英文的表示

> 逻辑模型是按计算系统的观点对数据建模，用于数据库系统的实现

逻辑模型是将信息世界转换为机器世界得到的模型

| 现实世界 | 信息世界 |       机器世界       |
| :------: | :------: | :------------------: |
|   实体   | 概念模型 | 数据模型（逻辑模型） |



### 概念模型

概念模型是信息世界到机器世界到一个中间层次

#### 现实世界中的基本概念

##### 实体

​	客观存在且可区分的事物，可以说人、事、物，也可以是概念或联系

​	比如一个学生，一门课，一次选课、教师和老师的关系等

##### 属性

​	实体所拥有的某一特性

​	实体可由多个属性来刻画

​	比如学生：

​	学号，性别，专业，院系，出生年月等来刻画

##### 码

​	唯一标识实体的属性集

​	如学号可以唯一标识一个学生，身份证号可以唯一标识一个公民

##### 实体型

​	实体名+属性

​	如

​	学生(学号、性别、院系、专业、出生年月、入学时间)

##### 实体集

​	同一类型实体的集合，如全体学生

##### 联系

​	现实世界的事物之间的联系，反应在信息世界中

​	就是实体型（型）内部的联系和实体（型）之间的联系

​	实体之间的联系有一对一、一对多和多对多

#### 概念模型的一种表示方法：实体-联系方法

实体-联系方法也成为E-R联系方法

用E-R图来描述现实世界的概念模型

### 数据模型的组成要素

数据模型通常由数据结构、数据操纵和数据的完整性约束三部分组成

#### 1.数据结构

描述数据库的组成对象以及对象之间的联系

是对系统的静态描述

#### 2.数据操纵

主要有查询和更新（插入、修改、删除）

#### 3.数据的完整性约束

即一组完整性规则，用以限定数据库中状态及状态的变化，保证数据的正确、有效和相容

### 常用的数据模型

#### 层次模型-----代表IMS

#### 网状模型------代表DBTG

#### 关系模型

#### 面向对象数据模型

#### 对象关系数据模型

#### 半结构化数据模型

其中层次模型和网状模型统称为格式化模型

基本层次联系：

是指两个记录以及它们之间的联系

双亲节点和子女节点

### 层次模型-----IMS

用树形结构来表示各类实体以及实体之间的联系

#### 层次模型的数据结构

基本层次关系符合两个条件即为层次模型

> 1.有且仅有一个结点没有双亲结点，这个节点称为根结点
>
> 2.根以外的结点有且只有一个双亲结点

层次模型像一棵倒立的树，结点的双亲是唯一的

> 层次模型只能处理一对多的关系

#### 层次模型的数据操纵与完整性约束

层次模型的数据操纵有查询、插入、删除和更新

进行数据操纵时要满足完整性约束

> 进行插入时，如果没有相应的双亲结点就不能插入他们的子女结点
>
> 进行删除时，如果删除双亲结点，他们的子女结点也将被同时删除

### 网状模型-----代表DBTG或CODASYL

#### 网状结构的数据结构

满足两个基本层次关系

> 允许一个以上结点无双亲
>
> 一个结点可以有多于一个的双亲

在层次模型中，子女结点与双亲结点的联系是唯一的

在网状模型中，子女结点与双亲结点的联系却是不唯一的

#### 网状结构的数据操纵与完整性约束

支持码的概念

双亲记录与子女呢记录之间可以是多对多的关系

是的网状模型比较复杂

### 关系模型

#### 关系模型的数据结构

关系模型由一组关系组成

每个关系的数据结构是一张规范的二维表

类似于Excel中的表

相关术语：

|    术语    |                    解释                     |
| :--------: | :-----------------------------------------: |
|    关系    |                     表                      |
| 元组/记录  |           表的一行为一个元组/记录           |
|    属性    |             表的一列为一个属性              |
| 码（码键） |         可以唯一确定一条元组的属性          |
|     域     |               属性的取值范围                |
|    分量    |    元组的一个属性值（必须是不可再分的）     |
|  关系模式  | 关系名（属性1，属性2，属性3...)类似于实体型 |
|   目/度    |                 属性的个数                  |



#### 关系模型的数据操纵与完整性约束

关系模型的数据操纵主要有查询、插入、修改删除和更新

在关系模型中的数据操纵是集合操纵，操纵对象和操纵结果都是关系

并将存取路径进行隐蔽

完整性约束包括三大部分：

实体完整性

参照完整性

用户定义的完整性

## 1.3数据库系统的结构

### 数据库系统模式的概念

在数据模型中有型和值的概念：

型是对数据结构和属性的说明

值是型的具体值

> 型
>
> 学生（姓名，年龄，院系）
>
> 值
>
> （吴晗，20，计算机学院）

而模式仅仅涉及型的描述

模式的具体值称为实例

模式是相对稳定的，而实例是相对变动的

### 数据库系统的三级模式结构

#### 模式

> 模式又称逻辑模式、概念模式，是所有用户的公共数据视图，是全局模型

即一张完整的表

通常用DDL来定义模型

#### 外模型

> 外模式又称用户模式、局部模式；是用户的数据视图，比如一个公司各个部门用的表，是不一样的

#### 内模型

> 内模式又称为存储模式、物理模式，描述数据库数据存储结构和存储方式。一个数据库只有一个内模型

### 数据库的二级映像功能与数据独立性

为了能够在系统内部实现三个抽象模式层次的联系和转换

在三层模式之间提供了两层映像：

外模式/模式映射和模式/内模式映射

#### 外模式/模式映射

> 当模式发送改变时，只需要修改外模式/模式映像，而不用修改外模式和应用程序
>
> 保证了数据与程序的逻辑独立性

#### 模式/内模式映射

> 当内模式发送变化时，只需要修改模式/内模式映射，可以保证模式和应用程序不改变
>
> 这就保证了程序与数据的物理独立性

数据与程序的独立性使得数据的定义和描述可以从应用程序中分离出去

## 1.4数据库系统的组成

### 硬件平台及数据库

数据库对硬件资源提出了各种要求，如内存、磁盘要大，通道能力要高，速度要快

### 软件

​	数据库管理系统、操作系统、编译系统一刻各种应用开发工具

### 人员

#### 数据库管理员（DBA)

负责全面管理和控制数据库管理系统

> 决定数据库信息内容和结构
>
> 决定数据库的存储结构和策略
>
> 定义数据库的安全性要求和完整性约束
>
> 监控数据库的使用和运行
>
> 数据库的改进和重组、重构

#### 系统分析员和数据库设计人员

#### 应用程序员

#### 用户

# 二、关系数据库

## 2.1关系数据结构及形式化定义

> 关系模式由关系数据结构、关系操作集合和关系完整性约束三部分组成

### 关系

关系模式中数据的逻辑结构就是一张二维表

关系模式时建立在集合代数的基础上的

于是从集合论的角度给出关系数据结构的形式化定义：

#### 域

​	域上椅子具有相同数据类型的集合，如整数、分数、整数

#### 笛卡尔积

​	笛卡尔积上域上的一种集合运算

> 基数：
>
> 域的取值个数

元素的每一个值称为一个分量

笛卡尔积的基数为它们的基数乘积

> D1=(a,b);
>
> D2=(1,2,3);
>
> D1 x D2 = {(a1),(a2)(a3)
>
> ​					(b1),(b2),(b3),
>
> ​					(c1),(c2),(c3);}

#### 关系

#### 候选码

> 候选码上一个属性值
>
> 定义：
>
> 能为宜标识一个元组的属性组，称该属性组为候选码

候选码的属性称为主属性

非候选码的属性称为非主属性

两种情况：

​	候选码只有一个属性

​	所有属性都是候选码，称为全码

#### 主码

​	若一个关系中有多个候选码，在其中选一个作为主码

#### 关系类型

> 关系有三种类型：
>
> 基本关系（基本表）、查询表和视图表
>
> 基本表时实际数据的逻辑表示
>
> 查询表时查询结果对应的表
>
> 视图表时虚表，由其他表导出的表，时不存在的表

### 关系模型

关系的描述称为关系模式

通常表示为

> R(A1,A2,A3...)

R表示关系名

A1,A2,A3表示属性，含属性的类型、长度等

关系模式时静态的、稳定的

二关系时动态的、随时间不断变化的

### 关系数据库

关系数据库中的型也称为模式，都是对关系数据库的描述

及关系模式==关系型

而关系数据库的值通常称为关系数据库

## 2.2关系操作

### 基本的关系操作

|  查询操作  | 更新操作 |
| :--------: | :------: |
|    选择    |   插入   |
|    投影    |   修改   |
|    连接    |   删除   |
|     并     |          |
|  笛卡尔积  |          |
| 除、差、交 |          |

> 其中，选择、投影、并、差、笛卡尔积时是5种基本操作

关系操作的特点是集合操纵，操作的对象和结果都是集合

### 关系数据语言的分类

| 关系代数语言 |   关系演算语言    | 介于关系代数和关系演算之间的语言 |
| :----------: | :---------------: | :------------------------------: |
|     ISBL     | 元组关系演算ALPHA |        结构化查询语言SQL         |
|              |   域关系演算QBE   |                                  |

SQL语言是一种高度非过程化的语言

集查询、数据定义语言、数据操纵语言和数据控制语言于一体

## 2.3关系的完整性

关系模型的完整性是对关系的约束条件

包括实体完整性、参照完整性和用户定义的完整性

### 实体完整性

​	实体完整性即主码属性不能为空

​	唯一标识一个元组的属性不能为空值

​	比如学生的学号不能为空值

### 参照完整性

外码：

​	是本关系的非主码，但是是另一个关系的主码（相对应）

外码不一定要和相应的主码同名

参照完整性即外码只能有两种情况：

1.为空

2.为另外一个关系的某个元组的主码

> 学生（<u>学号</u>，专业号，姓名，年龄）
>
> 专业（<u>专业号</u>，专业名字）
>
> 在学生表里的专业号就是外码
>
> 学生表为参照关系，专业表为被参照关系

参照表和被参照表可以是同一表

### 用户定义的完整性

用户根据实际需要来定义具体的完整性约束

## 2.4关系代数

关系代数是一种抽象的查询语言

用于对关系的运算来表达查询

分为传统的集合运算和专门的关系运算

### 传统的集合运算

传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算

#### 并

RUS

元组相加，除去重复元组

#### 差

R-S

找出R中有，但是S中没有的元组

#### 交

R∩S

找出二者都有的元组

#### 笛卡尔积

R x S

属性相加，元组相乘

### 专门的关系运算

象集：

在S中两个属性X,Y

当X取x1时，Y为y1,y2

当X取x2时，y为y1,y3

那么

x1在R中的象集为y1,y2

x2在R中的象集为y1,y3

#### 选择 σ

选择又称为限制。

时在关系中选择满足给的条件的元组

是从行的角度进行的运算

使用选择操作符（ σ ），在选择操作符（ σ ）右下角标定条件

> 比如 在学生表中选出年龄大于19岁的学生的元组
>
>  σSage>19(Student)

#### 投影π

投影是从关系中选出指定的属性列来组成新的关系

是从列的角度进行的运算

> 比如 从学生表中选出学号和姓名列
>
>  σSno,Sname(Student)

#### 连接

也叫θ连接。

是从两个关系的笛卡尔积中选取属性间满足条件的元组

分为等值连接和自然连接

> 等值连接即选择属性值相等的元组
>
> 自然连接是一种特殊的等值连接，去除了等值连接的重复属性列

一般的连接是从行的角度进行的运算

自然连接取消了重复列，是从行和列的角度进行的运算

> 在做自然连接操作时，被舍弃的元组称为悬浮元组

将悬浮元组也放入结果关系中

在其他没有对应内容的属性上填空值NULL，就称之为外连接

只保留左边关系的悬浮元组为左外连接

只保留右边关系的悬浮元组为右外连接

#### 除

R ÷ S = T

除运算分为三步：

1.找出R中与S非公共的属性列。并列出它在R中的象集，记为n

2.找到S中与R公共属性列的投影，记为m

3.找出n与m的交集所对应的n中的属性列

# 三、关系数据库标准语言SQL

## SQL概述

结构化查询语言SQL是关系数据库标准语言，也是通用的关系数据库语言

### SQL的产生和发展

目前，没有任何一个数据库系统能够支持SQL标准的所有概念和特性

同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性

### SQL的特点

#### 综合统一

SQL集数据定义语言、数据操纵语言、数据控制语言的功能于一体

语言风格统一

可以独立完成数据库生命周期中的全部活动

包括一系列操作要求：

> 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库
>
> 对数据库中的数据进行查询和更新
>
> 数据库重构和维护
>
> 数据库安全性、完整性控制，以及事务控制
>
> 嵌入式SQL和动态SQL定义

#### 高度非过程化

只要提出做“什么“，而不用指明”怎么做“

无须了解存取路径

因为存取路径的选择和SQL的操作过程有系统自动完成

#### 面向集合的操作方式

SQL采用集合的操作方式

操作对象是集合

操作结果也是集合

查找结果是集合

#### 以同一种语法结构提供多种使用方式

SQL既是独立的语言，又是嵌入式语言

既可以独立用于联机交互

又可以嵌入到高级语言（如Java、C、Python），供设计程序使用

而在两种不同的使用方式下

SQL的语法结构是基本一样的

#### 语言简洁，简单易学

完成核心功能只用了9个动词

| SQL功能  | 动词                 |
| :------: | -------------------- |
| 数据查询 | SELECT               |
| 数据定义 | CREATE,DROP,ALTER    |
| 数据操纵 | INSERT,UPDATE,DELETE |
| 数据控制 | GRANT,REVOKE         |

### SQL的基本概念

支持SQL的关系数据库管理系统同样也支持关系数据库三级映射模式结构

| 三级映射结构 |   内容   |
| :----------: | :------: |
|    外模式    |   视图   |
|     模式     |  基本表  |
|    内模式    | 存储文件 |

基本表上本身独立存在的表，一个关系对应一个基本表

一个或多个基本表对应一个存储文件

一个表可以带若干索引

索引页存放在存储文件中

视图是从一个或多个基本表导出的表，是一个虚表

因为数据库中只存放视图的定义而不存放视图对应的数据

视图在概念上与基本表等同，用户可以在视图上再定义视图

## 数据定义

关系数据库系统支持三级映射模式结构

模式、外模式、内模式中的基本对象有模式、视图和索引

所以SQL的数据定义包括模式定义、表定义、视图和索引定义

|      | 创建          | 删除        | 修改        |
| ---- | ------------- | ----------- | ----------- |
| 模式 | CREATE SCHEME | DROP SCHEME |             |
| 表   | CRTATE TABLE  | DROP TABLE  | ALTER TABLE |
| 视图 | CREATE VIEW   | DROP VIEW   |             |
| 索引 | CREATE INDEX  | DROP INDEX  | ALTER INDEX |

SQL标准不提供修改模式定义和修改视图定义的操作

> 一个关系数据库管理系统的实例中可以创建多个数据库
>
> 一个数据库中可以创建多个模式
>
> 一个模式下通常包括多个表、视图和索引等数据库对象

### 模式的定义与删除

#### 定义模式

```sql
//CREATE SCHEMA <模式名>AUTHORIZATION<用户名>
/*为用户wuhan定义一个学生-课程模式“S-T"*/
CREATE "S-T" AUTHORIZATION wuhan;
```

可以在创建模式等定义中进一步创建基本表、视图

```sql
CREATE SCHEMA TEST AUTHORIZATION WUHAN
CREATE TABLE STUDENT{SCO1 SMALLINT;
										SCO2 INT;
										SCO3 CHAR(3)
					
}
```



#### 删除模式

```sql
//DROP SCHEMA <模式名><CASCADE|RESTRICT>
CASCADE:级联，表示会删除模式和模式中的所有数据库对象
RESTRICT：如果模式不为空，则无法删除
DROP SCHAME STUDENT CASCADE;
/*STUDENT中基本表也被删除了*/
```

### 基本表的定义、删除与修改

#### 定义基本表

```sql
/*
CREATE TABLE <表名>(
			<列名><数据类型><列级完整性约束条件>;
			<列名><数据类型><列级完整性约束条件>;
			................
			<列名><数据类型><列级完整性约束条件>
)
*/
/*定义一个学生表
分别是学号，姓名，性别，年龄，所在系*/

CREATE TABLE Student(
  		Sno CHAR(9) PRIMARY KEY;/*列级完整性约束条件，为主码*/
  		Sname CHAR(20) UNIQUE;/*取唯一值*/
  		Ssex CHAR(2);
  		Sage SMALLINT;
  		Sdetp CHAR(20)
)
/*定义一个课程表
分别是课程号、课程名、先修课*/
CREATE TABLE Course(
			Cno CHAR(4) PRIMARY KEY;/*列级完整性约束条件，Cno是主码*/
  		Cname CHAR(40) NOT NULL;/*列级完整性约束条件，Cname不能为空*/
  		Cpno CHAR(4);
  		FOREIGN KEY(Cpo) REFERENCES Course(Cno)
  		/* 表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno
  		参照表和被参照表可以是同一个表*/
)
/* 定义一个学生选修课程表
分别是学号、课程号、分数*/
CREATE TABLE SC(
				Sno CHAR(9);
  			Cno CHAR(4);
  			Grade SMALLINT;
  			PRIMARY KEY(Sno,Cno);/* 主码由两个属性组成，必须作为表级完整性约束进行定义*/
  			FOREIGN KEY(Sno) REFERENCES Student(Sno);
  		/* 表级完整性约束条件，Sno是外码，被参照表是Student */
  			FOREIGN KEY(Cno) REFERENCES Course(Cno)
  	/* 表级完整性约束条件，Cno是外码，被参照表是Course */
)
```

#### 数据类型

|            数据类型             |              含义              |
| :-----------------------------: | :----------------------------: |
|      CHAR(n)，CHARACTER(n)      |     长度为n的可变长字符串      |
| VARCHAR(n)，CHARACTERVARCHAR(n) |   最大程度为n的可变长字符串    |
|              CLOB               |          字符串大对象          |
|              BLOB               |          二进制大对象          |
|           INT,INTEGER           |          长整型4字节           |
|            SMALLINT             |          短整型2字节           |
|             BIGINT              |          大整数8字节           |
|          NUMERIC(p,d)           | 定点数，由p为数字，小数点后d位 |
|      DECIMAL(p,d),DEC(p,d)      |         同NUMERIC(p,d)         |
|              REAL               |            单精度数            |
|        DOUBLE PRECISION         |            双精度数            |
|            FLOAT(n)             |        浮点数，n位数字         |
|             BOOLEAN             |          逻辑布尔常量          |
|              DATE               |        日期，年、月、日        |
|              TIME               |        时间，时、分、秒        |
|            TIMESTAMP            |             时间戳             |
|            INTERVAL             |            时间间隔            |

#### 模式与表

一个表属于一个模式，一个模式有多个表

定义表时有三种方法定义它的模式：

```sql
/* 1.在表名中明显地给出模式名*/
CREATE TABLE "S-T".Student(..)/*Student所属的模式是S-T */
CREATE TABLE "S-T".Course(...)/* Course所属的模式是S-T*/
CREATE TABLE "S-T".SC(...)/*SC所属的模式是S-T */
/*2.在创建模式语句中同时创建表*/
CREATE SCHEMA TEST AUTHORIZATION WUHAN
CREATE TABLE STUDENT{SCO1 SMALLINT;
										SCO2 INT;
										SCO3 CHAR(3)
					
}
/* 3.设置所属的模式，通过搜索路径来确定表的模式*/
SHOW search_path;//显示搜索路径
/* 先设置搜索路径，再定义表*/
SET search_path TO "S-T",PUBLIC;
CREATE TABLE Student(...);
```

#### 修改基本表

```sql
/*
ALTER TABLE<表名>
[ADD[COLUMN <新列名><数据类型>[完整性约束条件]]]
[ADD<表级完整性约束条件>]
[DROP[COLUMN]<><CASCADE|RESTRICT]/*删除列*/
[DROP CONSTRAINT<>[CASCADE|RESTRICT]]/* 删除指定的完整性约束条件*/
[ALTER COLUMN<列名><数据类型>]
*/
/* 用于添加新列，新的列级表级完整性约束条件*/

/* 向Student学生表增加“入学时间”列，数据类型位日期类*/
ALTER TABLE Student ADD S_entrance DATE;

/* 将年龄的数据类型由字符型改为整数*/
ALTER TABLE Student ALTER Sage INT;

/* 为课程名称增加必须取唯一值的约束条件 */
ALTER TABLE Courde ADD UNIQUE(Cname);
```

#### 删除基本表

```sql
/* DROP TABLE <表名>[RESTRICT|CASCADE] */

/*
若用RESTRICT，会有很多限制条件
不能被其他表应用，不能有视图
不能有触发器
不能有存储过程或函数等等
*/

/*删除学生表 */
DROP TABLE Student CASCADE;
```

### 索引的定义与删除

> 数据库的索引有多种类型
>
> 顺序文件上的索引：按属性值的排序（升或降
>
> B+树索引：将索引属性组织成B+数形式
>
> 散列索引：建立桶，将索引属性按照散列函数值映射到桶中
>
> 位图索引：用位向量记录索引属性中kennel出现的值

用户不必显式地选择索引

#### 建立索引

```SQL
/*
CREATE[UNIQUE][CLUSTER] INDEX<索引名>
ON<表名>(<次序>[，<列名>[次序]])
*/
/*
索引可以建立在表的一列或多列上
列的后面可以指定索引的排序，默认为ASC
ASC（升序） DESC（降序）

UNIQUE表明此索引的每一个索引值只对应唯一的数据记录
CLUSTER表明要建立的是聚族索引
*/

/* 为学生-课程数据库中的学生、课程、选修三个表建立索引
	分别是按学号升序建立唯一索引
			按课程号升序建立唯一索引
			按学号升序和课程号排序建立唯一索引
*/
CREATE UNIQUE INDEX Stusno ON Student(Sno);
CREATE UNIQUE INDEX Coucno ON Course(Cno);
CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC);
```

#### 修改索引

```sql
/*
ALTER INDEX<旧索引名>RENAME TO <新索引名>;
*/

/* 把SC表的SCno索引名改为SCSno*/
ALTER INDEX SCno RENAME TO SCSno;
```



#### 删除索引

```sql
/* DROP INDEX<索引名> */

/*删除Student表的Stuname索引*/
DROP INDEX Stuname;
```

### 数据字典

数据字典是关系数据库管理系统的一组系统表

记录了数据库中的各种信息

关系数据库在执行SQL语句时，实际上就是在更新数据字典表中的相应信息

## 数据查询

```sql
/* 一般格式为：
SELECT[ALL|DISTINCT]<目标列表达式>[]...
FROM<表名或视图名>[](SELECT语句)[AS]<别名>
[WHERE<条件表达式>]
[GROUP BY<列名>[HAVING<条件表达式>]]
ORDER BY<列名[ASC|DESC]
*/
/* 
整个语句的含义是：
根据WHERE自己的条件表达式从FROM子句指定的表中找出满足条件的元组
再按SELECT子句中的目标表达式选出元组中的属性值形成结构表
GROUP BY是进行分组，通常每组中作用聚集函数
HAVING指定条件
ORDER BY子句进行排序
*/
```

### 单表查询

#### 选择表中若干列

```sql
/* 1.查询指定列*/

/* 查询全体学生的学号和姓名*/

SELECT Sno,Sname
FROM Student;

/*-------------------------------------*/
/*2.查询全部列，用*指定所有的列 */

/* 查询全体学生的详细信息*/

SELECT *
FROM Student;

/*--------------------------------------*/
/* 3.查询结果计算的值 */
/* SELECT子句中的目标表达式，不仅可以是属性列，也可以是表达式. */

/*查询全体学生的姓名及出生年份(当前年份-年龄)*/

SELECT Sname,2021-Sage
FROM Student;

/*查询全体学生的姓名及出生年份(当前年份-年龄)和所在院系,要求用小写字母表示系名*/
SELECT Sname,'Year of Birth:',2021-Sage,LOWER(Sdept)
FROM Student;


/* --------------------------------------------------------------*/
/*
用户可以通过指定别名来改变查询结果的列标题
*/
SELECT Sname NAME,'Year of Birth:'BRITH,2021-Sage BIRTHDAY,LOWER(Sdept)DEPARTMENT
FROM Student;
```



#### 选择表中若干元组

```sql
/* ---------1.消除取值重复的值----DISTINCT----------*/

/* 选修了课程的学生学号*/
SELECT DISTINCT Sno
FROM SC;

/* 没有DISTINCT就是等效于*/
SELECT ALL Sno
FROM SC;
/* ---------2.查询满足条件的元组------WHERE--------------*/

/*------------比较大小-------------------- */
/* 查询20岁以下的学生姓名和年龄*/
SELECT Sname,Sage
FROM Student
WHERE Sage<20;

/* --确定范围---(NOT)-BETWEEN---AND----------*/
/* 查询20-30岁之间的学生姓名，年龄*/
SELECT Sname,Sage
FROM Student 
WHERE Sage BETWEEN 20 AND 30;
/* --------------确定集合--(NOT)----IN--------*/
/* 查询计算机系（CS)和数学系（MATH)的学生的姓名和性别*/
SELECT Sname,Ssec
FROM Student
WHERE Sdetp IN('CS','MATH');
/*--------------字符匹配------LIKE---------- */
/*
LIKE<'匹配符'> [ESCAPE'<换码字符>']
%任意长度字符
_代表任意单个字符
*/
/* 查询所有姓刘的学生姓名、性别*/
SELECT Sname,Ssex
FROM Student
WHERE Sname LIKE '刘%';
/* 当要查询的字符中含有通配符，据需要用ESCAPE进行转义*/
/*查询DB_Design课程的课程号和学分*/
SELECT Cno，Credit
FROM Course
WHERE Cname LIKE 'DB\_Design' ESCAPE'\'';
/* --------涉及空值的查询-------NULL--------- */
/*  查询没有成绩的学生姓名和性别*/
SELECT Sname,Ssex
FROM Student
WHERE Grade IS NULL;
/* -------多重条件查询---AND-----OR----------*/
/* 查询计算机系年龄20岁以下的学习姓名，年龄*/
SELECT Sname,Sage
FROM Student
WHERE Sdep="CS" AND Sage<20;
```



#### ORDER BY子句

使用ORDER BY子句可以对结果进行排序，升序(ASC)或降序(DESC)

```sql
/* 查询选修了3号课程的学生的学号，姓名和成绩，结果按成绩分数就进行降序*/
SELECT Sno,Sname,Grade
FROM SC
WHERE Cnoq='3'
ORDER BY Grade(DESC);
```



#### 聚集函数

|            聚集函数            |        功能        |
| :----------------------------: | :----------------: |
|            COUNT(*)            |    统计元组个数    |
| COUNT([DISTINCT\|ALL]<COLUMN>) | 统计一列中值的个数 |
|  SUM([DISTINCT\|ALL]<COLUMN>)  |  计算一列值值总和  |
|  AVG([DISTINCT\|ALL]<COLUMN>)  | 计算一列值的平均值 |
|  MAX([DISTINCT\|ALL]<COLUMN>)  |  求一列值的最大值  |
|  MIN([DISTINCT\|ALL]<COLUMN>)  |  求一列值的最小值  |
|      DISTINCT是去除重复值      |                    |

```sql
/* 查询学生总人数*/
SELECT COUNT(*)
FROM Student

/* 查询选修了课的学生人数*/
SELECT COUNT(DISTINCT Sno)
FROM SC;

/* 计算选修了1号课程的学生平均分数*/
SELECT AVG(Grade)
FROM SC
WHERE Cno='1'

```



#### GROUP BY子句

GROUP BU子句将查询结果按某一列或多列的值分组，值相等的为一组

对结果进行筛选，可以用HAVING子句

因为WHERE子句是不能使用聚集函数的

> 对查询结果分组的目的是为了细化聚集函数的作用对象
>
> 如果未对查询结果分组
>
> 聚集函数将会作用整个查询结果

```sql
/*
查询各个课程号以及选课人数
按课程号进行分组，统计每个课程号的人数
*/
SELECT Cno,COUNT(DISTINCT Sno)
FROM SC
GROUP BY Cno;

/* 查询选修了三门课以上对学生学号*/
SELECT Sno
FROM SC
GROUP BY Sno
HAVING COUNT(*)>3;
```



### 连接查询

> 当涉及多个表之间的查询，就要使用连接查询

连接查询包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询

#### 等值与非等值连接查询

> 连接查询的WHERE子句中用来连接两个表的条件称为连接谓词或连接条件
>
> 当连接运算符为=时，称为等值连接
> 其他运算符为非等值连接
>
> 连接谓词中的列名称为连接字段
>
> ```sql
> /*
> [<表名1>]<列名1><比较运算符>[<表名2>]<列名2>
> */
> 
> /*
> [<表名1>]<列名1>BETWEEN[<表名2>]<列名2>AND[<表名3>]<列名3>
> */
> 
> 
> /*查询每个学生的选修课程情况*/
> SELECT Student.*,SC.*
> FROM Student,SC
> WHERE Student.Sno=SC.Sno;
> /*
> 两个表是通过公共属性Sno实现的
> SELECT子句和WHERE子句中都使用了表名前缀，这是为了避免混淆
> 
> */
> ```
>
> > 嵌套循环连接算法的基本思想：
> >
> > 先在Student表中找到第一个元组
> >
> > 然后扫描SC表，找到与之匹配的元组
> >
> > 将元组进行拼接得到第一个目标元组
> >
> > 然后循环操作，直到所有元组都找到

而如果建立了索引的话，就不用进行扫描了

> 在等值连接中把重复属性列去除则为自然连接

WHERE子句是由连接谓词和选择谓词构成的复合条件

```sql
/*查询选修2号课程且成绩在90分以上的学生的学号和姓名*/
SELECT Sno,Sname
FROM SC,Student
WHERE SC.Sno=Student.Sno AND
			Grade>90 AND Cno='2';
/*
先选出2号课程并且成绩在90分以上的元组形成一个中间关系
再和Student中满足连接条件的元组进行连接得到最终的结果关系
*/
```



#### 自身连接

即一个表和表自身进行连接

```sql
/*
查询每一门课程的先修课的先修课
要先查询课程的先修课，再按先修课的课程号找到先修课
就要进行自身连接
为Course取两个别名FIRST,SECEND
*/

SELECT FIRST.Cno,SECEND.Cno
FROM Course FIRST,Course SECEND
WHERE FIRST.Cpno=SECEND.Cno;
```



#### 外连接

把悬浮元组保存在结果关系中，把没有内容的属性填上NULL

即外连接

```sql
/*左外连接*/
SELECT Stuent.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
FROM Student LEFT OUTER JOIN SC ON(Student.Sno=SC.Sno)
```



#### 多表连接

```sql
/*查询每个学生的学号、姓名、选修的课程名及成绩*/
SELECT Sno,Sname,Cno,Grde
FROM Student,Cno,SC
WHERE Student.Sno=Course.Sno AND
			Course.Cno=SC.Cno;
```



### 嵌套查询

在SQL中，一个SELECT-FROM-WHERE语句成为一个查询块

将一个查询块嵌套在另一个查询块的WHERE子句或HAVIING子句中为嵌套查询

```sql
SELECT Sname/* 父查询，外层查询*/
FROM Student
WHERE Sno iN
			(SELECT Sno/*内存查询，子查询*/
      FROM SC
      WHERE Cno='2');
    
```

子查询的SELECT子句不能使用ORDER BY子句

ORDER BY子句只能用于对最终结果的排序

嵌套循环可以将简单查询构成复杂的查询，增强SQL的功能

#### 带有IN谓词的子查询

在嵌套查询中，子查询通常是一个集合，所有会经常使用IN

不依赖于父查询的子查询，称为不相关子查询

子查询的查询条件依赖于父查询的，称为相关子查询

```sql
/* 查询与“刘晨”在同一个系的学生*/

/*
1.确定刘晨所在系,结果为CS
*/
SELECT Sdept
FROM Student
WHERE Sname='刘晨';

/*2.查找CS系的学生*/
SELECT *
FROM Student
WHERE Sdept='CS';

/*将第一步嵌套到第二步就是：*/
SELECT *
FROM Student
WHERE Sdept IN(
					SELECT *
					FROM Student
					WHERE Sname='刘晨');
					
/*即先执行子查询再执行父查询*/
```



#### 带有比较运算符的子查询

带有比较运算符的子查询指的是付查询和子查询之间用比较运算符进行连接

```sql
SELECT *
FROM Student
WHERE Sdept =(
					SELECT *
					FROM Student
					WHERE Sname='刘晨');
					
/*找出每个学生超过他自己选修课程平均成绩的课程号*/
SELECT Sno,Cno
FROM SC x
WHERE Grade>=(
						SELECT AVG(Grade)
						FROM SC y
						WHERE y.Sno=x.Sno);
	/*这就是相关子查询*/
/*
执行过程：
	1.从外循环中去取一个元组的Sno放入子循环
	2.执行子循环，得到一个值，用这个值代替内循环，得到外资循环
	3.执行这个循环
	4.循环执行1-3
*/
```



#### 带有ANY(SOME)或ALL谓词的子查询

查询返回单值时可以用比较运算符

但时返回多指就要用ANY 或ALL谓词

```sql
/*查询非计算机系中比计算机系任意一个学生年龄小的学生姓名和年龄*/
SELECT Sname,Sage
FROM Student
WHERE Sage<ANY(
						SELECT Sage
						FROM Student
						WHERE Sdept='CS')
			AND Sdept!='CS';
```



#### 带有EXITS谓词的子查询

EXITS带表存在量词

带有EXITS谓词的子查询不反悔任何数据

只产生逻辑值"ture"或"false"

```sql
/*查询选修了1号课程的学生姓名*/
SELECT Snam
FROM Student
WHERE EXITS(
			SELECT *
			FROM SC
			WHERE Sno=Student.Sno AND Cno='1');
```

由EXITS引出的子查询，其目标表达式通常都用*，因为只查询是否有，给出列名无实际意义

### 集合查询

SELECT语句的查询结果是元组的集合

所以多个SELECT语句的结果可进行集合操作

集合操作主要包括

并操作UNION、交操作INTERSECT、差操作EXCEPT

```SQL
/*查询计算机系的学生及年龄不大于19岁的学生*/
SELECT *
FROM Student
WHERE Sdept="CS"
UNION
SELECT *
FROM Student
WHERE Sage<=19;

/*既选修了1号课程又选修了2号课程的学生*/
SELECT *
FROM Student
WHERE Cno='1'
INTERSECT
SELECT *
FROM Student
WHERE Cno='2';
```



### 基于派生词的查询

子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中

这是子查询生成的临时派生表成为主查询的查询对象

```sql
/*查询选修了1号课程的学生姓*/
SELECT Sname
FROM Student,(SELECT Sno FROM WHERE Cno='1')AS SC1
WHERE Student.Sno=SC1.Sno;

/*----AS后面接派生表的别名--*/
```



### SELECT语句的一般格式

```sql
/*
SELECT语句的一般格式
SELECT [DISTINCT|ALL]
FROM [表]
WHERE[条件表达式]
GROUP B<列名>[HAVING 条件表达式]
ORDER BY<列名>[ASC|DESC]

*/
```



## 数据更新

### 插入数据INSERT

#### 插入元组

```sql
/*
INSERT
INTO <表>[属性]
VALUES(值)
*/

/*将吴晗的信息插入Student表中*/
INSERT
INTO Student(Sname,Ssex,Sage,Sdept)
VALUES(’吴晗‘，’男‘，20，’CS‘);
```



#### 插入子查询结果（多个元组）

```sql
/*
INSERT
INTO<表名>[属性列]
子查询；
*/

/*
对每一个系，求平均年龄，然后将结果存如数据库
*/
/*1.建立新表，存储平均年龄*/
CREATE TABLE AVERA(
			Sdept CHAR(4),
			Avg_age SAMLLINT);

/*2.求每个系的平均年龄，并存入数据库*/
INSERT 
INTO AVERA(Sdept,AVg_age)
SELECT Sdept,AVg_age
FROM AVERA
GROUP BY Sdept;
```



### 修改数据

```sql
/*
UPDATE<表名>
SET<列名>=<表达式>
WHERE<条件表达式>
*/
```

#### 修改一个元组的值

```sql
/*将吴晗的年龄改为18岁*/
UPDATE Student
SET Sage=18
WHERE Sname='吴晗';
```



#### 修改多个元组的值

```sql
/*将所有学生的年龄减少一岁*/
UPDATE Student
SET Sage=Sage-1
```



#### 带子查询的修改语句

```sql
/*将计算机系学生的成绩重置为0*/
UPDATE Course
SET Sage=0
WHERE Sno IN(
			SELECT Sno
			FROM Student
			WHERE Sdept='CS');
```



### 删除数据

```sql
/*
DELETE
FROM<表名>
WHERE<条件表达式>
*/
```

#### 删除某一个元组的值

```sql
/*删除吴晗的记录*/
DELETE 
FROM Student
WHERE Sname='吴晗';
```



#### 删除多个元组的值

```sql
/*删除所有学生的选课记录*/
DELETE 
FROM SC
```



#### 带子查询的删除语句

子查询同样可以嵌套在子查询中

```sql
/*删除计算机系的选课记录*/
DELETE
FROM SC
WHERE Sno IN(
			SELECT Sno
			FROM Student
			WHERE Sdept'CS');
```



## 空值的处理

所谓空值就是"不存在"不确定"不知道"的含义

空值含义不确定性

#### 空值的产生

空值的运算会产生空值

没有赋值会产生空值

#### 空值的判断

IS NULL,IS NOT NULL

```sql
/*从学生表中找出填漏了数据的学习信息*/
SELECT *
FROM Student
WHERE Sname IS NULL OR Sage IS NULL OR Ssex IS NULL OR Sdept IS NULL;
```



#### 空值的约束条件

NOT NULL 规定不能取空值

#### 空值的算术运算、比较运算和逻辑运算

空值的运算结果为UNKOWN	

## 视图

视图是从基本表导出的虚表

数据库中只能存放视图的定义，而不存放视图对应的数据

这些数据仍然存放在原来的基本表中

所以一旦基本表发生变化，视图也会相应发生改变

视图就像一个窗口

视图一经定义，就可以像基本表一样被查询、删除

也可以在视图之上再定义新的视图，但是会有很多限制

### 定义视图

#### 建立视图

```sql
/*
CREATE VIEW<视图名>[列名]
AS<子查询>
[WITH CHECK OPTION];
*/
```

WITH CHECK OPTION表示对视图就行更新、插入、删除操作时要保证更新、插入或删除的行满足殊途定义中的谓词条件

组成视图的属性列要么全部指定，要么全部省略，没有第三种选择

以下三种情况必须指定组成视图的所有列名

1.某个属性列含聚集函数或列表达式

2.多表连接时选出了几个同名列作为视图的字段

3.需要在视图中为某个列启用新的更合适的名字

```sql
/*建立计算机系学生的视图*/
CREATE VIEW CS_Student
AS
SELECT Sno,Sname,Ssex,Sage
FROM Student
WHERE Sdept='CS';
```

执行CREATE VIEW的结果只是把视图的定义存入数据库字典，并不执行SQL语句

之上再查询视图时，才将视图的定义从基本表将将数据查出

```sql
/*建立计算机系学生的视图*/
CREATE VIEW CS_Student
AS
SELECT Sno,Sname,Ssex,Sage
FROM Student
WHERE Sdept='CS'
WITH CHECK OPTION;
/*
加入WITH CHECK OPTION后，之后对该视图的操作
关系数据库系统会自动加上Sdept='CS'的条件
*/
```

若一个视图上从单个基本表导出的

并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图

```sql
/*视图不仅可以建立在单个基本表上，也可以建立在多个基本表上*/
/*建立信息系选修了1号课程的学生的视图*/
CREATE VIEW S1_1(Sno,Sname,Grade)
AS
SELECT Sno,Sname,Grade
FROM Student,SC
WHERE Sdept='IS'AND
			Student.Sno=SC.Sno AND
			SC.Cno='1';
/*也可以建立在定义号的视图之上*/
/*建立信息系选修了1号课程并且分数在90分以上的学生*/
CREATE VIEW IS_2
AS 
SELECT Sno,Saname
FROM S1_1
WHERE Grade>=90
```

由于视图中的数据并不存储，所以定义的列称为虚拟列

带虚拟列的视图也称为带表达式的视图

```sql
/*定义一个反应学生出生年份的视图*/
CREATE VIEW B_S(Sno,Sname,Sbirth)
AS
SELECT Sno,Sname,2014-Sage
FROM Student;
```

还可以用带有聚集函数和GROUP BY子句的查询来定义视图，这种视图称为分组视图

```sql
/*将学生的学号及平均成绩定义为一个视图*/
CREATE VIEW S_G(Sno,Gavg)
AS
SELECT Sno,AVG(Grade)
FROM SC
GROUP BY Sno;
```



#### 删除视图

将视图的定义从数据字典中删除

CASCADE是将于该视图有关联的视图一并删除

```sql
DROP VIEW <视图名>[CASCADE];

/*删除视图S_G*/
DROP VIEW S_G CASCADE;
```



### 查询视图

视图定义之后，就可以像基本表一样对视图进行查询了

进行视图查询时，首先检查视图是否存在

如果存在，则从数据字典中取出视图的定义，把子定义的子查询和用户的查询结合起来

转换成等价的对基本表的查询，然后再执行修正了的查询

称之为视图消解

```sql
SELECT Sno,Sage
FROM IS_Student
WHERE Sage<20;

/*视图消解后：*/
SELECT Sno,Sage
FROM IS_Student,SC
WHERE Sdept='IS' AND Sage<20;
```



### 更新视图

视图不是实际存在的视图，所以对视图的更新要转换为对基本表的更新

```sql
/*将吴晗的学号改为2021*/
UPDATE IS_Student
SET Sno=2021
WHERE Sname='吴晗';

/*----转换后的更新语句为----*/
UPDATE Student
SET Sno=2021
WHERE Sname='吴晗' AND Sdept='IS';
```

然而，并不少所有视图都可以更新的

### 视图的作用

#### 1.简化用户操作

#### 2.是的用户可以从多角度看待同一数据

#### 3.视图对重构数据库提供了一定程度的逻辑独立性

#### 4.视图能够对机密数据提供安全保护

#### 5.适当利用视图可以更清晰地表达查询

# 四、数据库安全性

## 数据库安全性概述

数据库安全性是指保护数据库以防止不合法使用造成的

数据泄露、更改或破坏

系统安全保护措施是否有效是数据库系统的主要技术指标之一

### 数据库的不安全因素

#### 1.非法用户对数据库的恶意存取和破坏

#### 2.数据库中重要或敏感的数据被泄露

#### 3.安全环境的脆弱性（计算机系统）

### 安全标准简介

标准化安全评估被称为通用准则项目（CC）

2001年我国采用为国家标准(CC v2.1)

TCSEC又称为桔皮书

TCSEC/TDI又称紫皮书

从四个方面来描述安全性能级别的指标

安全策略、责任、保证和文档

TESEC/TDI将系统分为4组7个等级，依次为D ,C(C1,C2),B(B1,B2,B3),A(A1);按系统可靠性依次逐渐增高

其中两个重要级别:

C1:

​	自主安全保护，可进行自主存取控制

B1:

​	标记安全保护，对系统数据加以标记

​	B1级别的安全产品才被认为是真正意义上的安全产品



CC评估保证级：

| 评估保证级 |           定义           | TXSEC安全级别 |
| :--------: | :----------------------: | :-----------: |
|    EAL1    |         功能测试         |               |
|    EAL2    |         结构测试         |      C1       |
|    EAL3    |     系统地测试和检查     |      C2       |
|    EAL4    |  系统地设计、测试和复查  |      B1       |
|    EAL5    |    半形式化设计和测试    |      B2       |
|    EAL6    | 半形式化验证的设计和测试 |      B3       |
|    EAL7    |    形式化的设计和测试    |      A1       |



## 数据库安全性控制

### 用户身份鉴别

用户身份鉴别是数据库管理系统提供的最外层安全级别保护措施

每个月还有在系统中都有一个用户标识

每个用户标识由用户名（user name）和用户标识号(UID)两部分组成

UID在系统的整个生命周期内是唯一的 

系统内部记录着所有合法用户的标识

系统鉴别是由系统提供一定的方式让用户标识自己的名字或身份

每次用户接进入系统时，有系统进行核对，通过鉴定后才提供数据库管理系统的权限

通常的用户鉴别方法有4种：

#### 1.静态口令鉴别

#### 2.动态口令鉴别

#### 3.生物特征鉴别

#### 4.智能卡鉴别

### 存取控制

数据库系统最重要的一点就是确保授权了资格的合法用户可以访问数据库，同时让未经授权的人员无法接近数据

这是通过数据库的存取控制机制实现

存取控制由两部分组成：

定义用户权限和合法权限检查

1.定义用户权限，并把用户权限登记到数据字典中

2.合法权限检查

​	定义用户权限和合法权限检查机制一起组成了数据库系统的存取控制子系统

C2级别的数据库管理系统支持自主存取控制：

B1 级别的数据库管理系统支持强制存取控制

### 自主存取控制方法(C2级别）

用户可以自主地决定数据的存取权限授予何人、决定是否也将“授予”的权限授予别人

即通过授权机制有效的控制对敏感数据的存取

这样的存取控制完全是自主的。所以称为自主存取控制方法

SQL通过GRANT和REVOKE语句来实现对自主存取控制的支持

用户的权限有两个要素组成：

数据库对象和操作类型

定义存取权限称为授权

存取控制的对象不仅有数据（数据，属性列）本身，还有数据库模式（模式，表，视图）

### 授权：授予与收回

#### GRANT

```sql
GRANT<权限>
ON<对象类型><对象名>
TO<用户>
WITH GRANT OPTION;
/*将制定操作对象的指定操作权限授予指定的用户*/
/*WITH GRANT OPTION是的获取了某种权限的用户可以把权限授予其他用户
但是不允许循环授予权限*/

/*把查询Student表的权限给用户U1*/
GRANT SELECT
ON Student
TO U1
WITH GRANT OPTION;

/*把查询SC表的权限给所有用户*/
GRANT SELECT
ON SC
TO PUBLIC
```



#### REVOKE

授予用户的权限可以由数据库管理员或其他授权者用REBOKE收回

```sql
/*
REVOKE <权限>
ON <对象类型>
FROM <用户>[CASCADE|RESTRICT]
*/

/*把用户U2修改学生学号的权限收回*/
REVOKE UPDATE(Sno)
ON TABLE Student
FROM U2;

/*收回所有用户对表SC的查询权限*/
REVOKE SELECT
ON TABLE SC
FROM PUBLIC;
```



#### 创建数据库模式的限制

```sql
CREATE USER<username>[WITH][DBA|RESOURCE|CONNECT];
```

只有超级用户才能有权创建一个新的数据库用户

新创建的数据库用户有三种权限：CONNECT,RESOURCE,DBA

CONNECT:

​	只能登陆，不能进行其他操作

RESOURCE：

​		能创建基本表和视图。但不能创建模式，不能创建新用户

DBE：

​	超级用户，拥有所有权限

### 数据库角色

数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合

#### 角色的创建



```sql
CREATE ROLE<角色名>
```



#### 给角色授权

```sql
GRANT <权限>
ON<对象>
TO<角色>
```



#### 讲一个角色授予其他的角色或用户

```sql
GRANT <权限>
TO<角色>
WITH ADMIN OPTION
```



#### 角色权限的收回

```sql
REVOKE <权限>
ON<对象>
FROM<角色>
```

```sql
/*创建用户*/
CREATE ROLE R1;

/*授权*/
GRANT SELECT,UPDATE,INSERT
ON TABLE Student
TO R1;

/*把这个角色授权给其他人*/
GRANT R1
TO 吴晗,张三;

/*回收权限*/
REVOKE R1
FROM 张三
```



### 强制存取控制方法(B1级别)

自主存取控制的安全性不能得到保证

因为自主安全性仅仅通过对数据的存取权限来进行安全控制，而数据本身无安全性标记

要解决这一问题，就需要在系统控制下的所有主客体实施强制存取策略

保证更高程度的安全性

> 在强取控制中，数据库系统所管理的全部实体分为主体和客体两大类
>
> 主体是系统的活动实体，包括数据库所管理的实际用户和代表用户的各进程
>
> 客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等
>
> 对于主体和客体，数据库管理系统为她们每个实例指派一个敏感度标记

敏感度分为若干级别：

绝密、机密、可信、公开，密级次序依次下降

遵循如下规则：

1.仅当主体的许可级别大于等于客体的密级时，该主体才能读取相应的客体

2.仅当主体的许可级别小于等于客体的密级时，该主体才能写相应的客体

强制存取控制是对数据本身进行密级标记，无论数据如何赋值

标记与数据是一个不可分的整体

只要有符合密级标记要求的用户才可以操纵数据，从而提供了更高级别的安全性

## 视图机制

可以为 不同用户定义不同的视图，把数据对象限制在一定的范围内

即通过视图机制把要保密的数据对无权存取对用户隐蔽起来

从而自动UI数据提供一定程度的安全性

视图机制间接的实现存取谓词的用户权限定义

## 审计（C2以上）

审计功能时数据库管理系统达到C2以上级别的不可少的一项指标

> 审计功能是把用户对数据库的所有操作自动记录下来放入审计日记中
>
> 审计员可以利用审计日记监控数据库中的各种行为
>
> 重现导致数据库现有状况的一系列事件
>
> 找出非法存取数据的人、事件和内容

### 审计事件

1.服务器功能

​	审计数据服务器发生的事件

​	如启动、停止、文件的重新加载

2.系统权限

​	对系统拥有的结构或模式对象进行操作的审计

3.语句事件

​	对SQL语句以及DCL语句的审计

4.模式对象事件

​	对特点模式对象上进行的SELECT,DML操作的审计

### 审计功能

- 基本功能，提供多种审计查阅方式
- 提供多套审计规则
- 提供审计分析和报表功能
- 审计日志管理功能
- 系统提供审计设置及审计记录信息的专门视图

### AUDIT语句和NOAUDIT语句

AUDIT用来设计审计功能

NOAUDIT用来取消审计功能

```sql
/*对修改SC结构或修改SC表数据的操作进行审计*/
AUDIT ALTER,UPDATE
ON SC;

/*取消对SC表的审计*/
NOAUDIT ALTER,UPDATE
ON SC
```

审计设置及审计日志一般都存储在数据字典中

必须把审计开关打开，才能在系统表中查看到审计信息

> 数据库的安全审计系统提供了一种事后检查的安全机制
>
> 安全审计机制将特地月还有或者特地对象相关的操作记录到系统审计日志中

## 数据加密

数据加密是防止数据库数据在存储和传输中失效的有效手段

>  加密的基本思想是根据一点的算法将原始数据--明文变换为不可直接识别的格式--密文
>
> 从而是的不知道解密算法的人无法获取数据的内容

数据加密主要包括存储加密和传输加密

### 存储加密

有非透明（加密函数）和透明（内核加密）两种存储的加密方式

### 传输加密

常用的有链路（链路层）加密和端到端（发生端加密、接收端解密）加密

## 其他安全性保护

### 推理控制

推理加密处理的是强制存取控制未解决的问题

用来避免用户利用其能够访问的数据推知更加密级的数据

### 隐蔽信道

也是处理的强制存取控制未解决的问题

> 数据隐私称为数据库应用中新的数据保护模式
>
> 所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力

# 五、数据库完整性

数据库的完整性是指数据的正确性和相容性

为维护数据库的完整性，数据库管理系统必须实现如下功能：

> 1.提供定义完整性约束条件1机制
>
> 2.提供完整性检查的方法
>
> 3.进行违约处理

关系数据库系统使得完整性控制称为其核心执行的功能

从而能够为所有用户和应用提供一致性的数据库完整性

## 实体完整性

### 定义实体完整性

关系模型的实体完整用CREATE TABLE.中的PRIMAYR KEY定义

对单属性有两种说明方法：

一种为列级约束条件

一种为表级约束条件

```sql
CREATE TABLE Student(
		Sno CHAR(9)PRIMARY KEY,/*列级完整性约束，列级定义主码*/
		Sname CHAR(20)NOT NULL,
		Ssex CHAR(2),
		Sage SMALLINT,
		Sdept CHAR(20)
);


CREATE TABLE SC(
		Sno CHAR(9)NOT NULL,
		Cno CHAR(4)NOT NULL,
		Grade SMALLINT,
		PRIMARY KEY(Sno,Cno)/*表级定义主码*/
);
```



### 实体完整性检查和违约处理

在定义了主码后，每当用户程序对基本表插入一条记录或对主码列进行跟新操作时

关系数据库管理系统会对实体完整性规则自动进行检查

> 1.检查主码是否唯一（不重复）
>
> 2.检查主码的各个属性是否为空（不为空）

检查主码是否唯一的方法：

全表扫描、建立索引

## 参照完整性

### 定义参照完整性

关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY定义外码

用REFERENCES指明外码所参照哪些表的主码

```sql
CREATE TABLE SC(
			Sno CHAR(9) NOT NULL,
			Cno CHAR(4)NOT NULL,
			Grade SMALLINT,
			PRIMARY KEY(Sno,Cno),/*定义表级实体完整性*/
			FOREIGN KEY(Sno)REFERENCES Student(Sno),/*在表级定义参照完整性*/
			FOREIGN KEY(Cno)REFERENCES Course(Cno)/*在表级定义参照完整性*/
);
```



### 参照完整性检查和违约处理

| 被参照表（Student） |    参照表（SC）    |        违约处理        |
| :-----------------: | :----------------: | :--------------------: |
| 可能破坏参照完整性  |      插入元组      |          拒绝          |
| 可能破坏参照完整性  |     修改外码值     |          拒绝          |
|      删除元组       | 可能破坏参照完整性 | 拒绝/级联删除/设置为空 |
|     修改主码值      | 可能破坏参照完整性 | 拒绝/级联删除/设置为空 |

”被参照找不到元组使其属性与外码的属性相等“这是根本原因

处理策略：

1.拒绝

2.级联删除

​	删除导致不一致的元组

3.设置为空值

## 用户定义的完整性

### 属性上的约束条

#### 属性上约束条件的定义

1.不允许取空值----NOT NULL

2.列值唯一-----UNIQUE

3.CHECK短语指定列值应该满足的条件

```sql
CREATE TABLE Student(
			Sno CHAR(9)PRIMARY KEY,
			Sname CHAR(8)UNIQUE NOT NULL,
			Ssex CHAR(2)CHECK(Ssex IN('男'，'女'))，
			Sage SMALLINT
);
```



#### 属性上约束条件的检查和违约处理

不满足条件，直接拒绝操作

### 元组上的约束条件

#### 元组上约束条件的定义

也是在CREATE TABLE中使用CHECK()对元组进行条件约束

```sql
CREATE TABLE Student(
			Sno CHAR(9),
			Sname CHAR(20)NOT NULL,
			Ssex CHAR(2),
			PRIMARY KEY(Sno),
  		CHECK(Ssex='女'OR Sname NOT LIKE 'Ms.%')
  /*-----定义了元组在Sname和Ssex两个属性之间的约束条件-----*/
);
```



#### 元组上约束条件的检查和违约处理

自动检查，不满足直接拒绝执行

## 完整性约束命名子句

SQL在CREATE TABLE中定义了完整性约束命名子句CONSTRAINT

用来对完整性约束条件命名

从而可以更加灵活的增加、删除一个完整性约束条件

### 完整性约束命名子句

```sql
CONSTRAINT<完整性约束条件名><完整性约束条件>
<完整性约束条件>包括
NOT NULL,UNIQUE,CHECK,PRIMARY KEY,FOREIGN KEY
```



```sql
CREATE TABLE Student(
			Sno CHARR(20)
				CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999),
       Sname CHAR(20)
           CONSTRAINT C2 NOT NULL),
				Sage SMALLINT
  				CONSTRAINT C3 CHECK(Sage<30)
  );
```

### 修改表中的完整性限制

ALTER TABLE语句可以修改表中的完整性限制

```sql
ALTER TABLE Student
		DROP CONSTRAINT C1;
ALTER TABLE Student
		ADD CONSTRAINT C1 CHECK(Sno BETWEEN 1000 AND 2000);
		
```

## 域中的完整性限制

使用CREATE DOMAIN建立一个域以及该域应该满足的完整性约束条件

如何就可以用域来定义属性

```sql
/*创建一个域，并声明性别域的取值范围*/
CREATE DOMAIN GenderDomain CHAR(2)
	CHECK(VALUE IN ('男','女'));
```



## 断言

通过声明性断言来指定更具一般性的约束

### 定义断言的语句格式

使用CREATE ASSERTION定义断言

```sql
CREATE ASSERTION<断言名><CHECK 子句>
```

```sql
/*限制数据库课程最多60名学生*/
CREATE ASSERTION ASS
	CHECK(60>=(SELECT  COUNT(*)
            FROM COurse,SC
            WHERE SC.CNO=COURSE.CNO AND COURSE.CNAME='数据库')
);
```

### 删除断言的语句格式

```sql
DROP ASSERTION<断言名>
```



## 触发器

触发器是用户定义在关系表上的一类由事件驱动的特殊性过程

一旦定义，触发器将被保存在数据库服务器中

任何用户对表的增删改操作均由服务器自动激活想要的触发器，

在关系数据库管理系统核心层进行集中的完整性控制

触发器类似于约束，但比约束更加灵活

触发器又叫“事务---条件---动作”规则

当特定的事务系统事件发生时，对规则的条件进行检查

如果条件成立则执行规则中的动作，否则不执行动作

### 定义触发器

SQL使用CREATE TRIGGER命令建立触发器

```sql
CREATE TRIGGER<触发器名>
/*------每当触发器事件发生时，该触发器被激活-------*/

{BEFORE|AFTER}<触发器事件>ON<表名>
/*----指明触发器激活的时间时在执行处罚事件前或后----*/

REFERENCING NEW|OLD ROW AS <变量>
/*-----REFERENCING指出引用的变量----*/

FOR EACH(ROW|STATEMENT})
/*-----定义触发器的类型，指明动作体执行的频率-----*/

[WHEN<触发条件>]<触发动作体>
/*-------仅当触发条件为真时才执行触发动作体------*/
```



### 激活触发器

触发器的执行是由处罚事件激活，并由数据库服务器自动执行

同一个表上的多个触发器激活时遵循如下的顺序：

> 1.执行该表上的BEFORE触发器
>
> 2.激活触发器的SQL语句
>
> 3.执行该表上的AFTER触发器

### 删除触发器

```sql
DROP TRIGGER<触发器名>ON <表名>
```

# 六、关系数据理论

## 问题的提出

>  针对一个具体问题，应该如何构造一个适合于它的数据库模式
>
> 即应该构造几个关系模式，每个关系由哪些属性组成等
>
> 这就是数据库等设计问题，确切的说是关系数据库逻辑设计问题

实际上设计任何一个数据应用系统，都会遇到如何构造合适的数据库模式即逻辑结构的问题

就关系模式为背景来讨论这个问题，形成了数据库设计的有力工具：

数据库的规范化理论

关系模式的形式化定义：

```sql
R(U,D,DOM,F)

R是符号化的元组语义
U为一组属性
D为U中的属性所来自的域
DOM为属性列到域的映射
F为属性组U上的一组数据依赖
```

由于D,DOM域模式设计关系不大

暂且把关系模式看作三个元组：

```
R<U,F>

当且仅当U上的一个关系r满足F时，r称为关系模式R<U,F>的一个关系
```

第一范式（1NF）：

> 每一个分量不可再分



数据依赖：

> 数据依赖是一个关系内部属性与属性之间的一种约束关系
>
> 这种关系时通过属性间值的相等与否体现出来的数据间的相互关系

其中最重要的是函数依赖和多值依赖

函数依赖：

> 比如学生基本表
>
> 一个学生只在一个系，一个学号只对应一个学生
>
> 因此，当学号确定后，学生和学生的系也就确定了
>
> Sname=f(Sno),Sdpt=f(Sno)
>
> 称为Sno决定Sname，Sno决定Sdpt
>
> Sname依赖于Sno,Sdpt
>
> 于是得到函数依赖：
>
> F={Sno->Sname,Sno->Sdpt}

而当函数依赖过于单一时，则会产生许多问题，如：

数据冗余

更新异常

插入异常

删除异常

就需要将单一的模式改变为多个关系模式

## 规范化

讨论属性间不同依赖情况，将不合适性质的关系转换为更合适的形式

通常按属性间依赖情况来区分关系规范化程度为

第一范式、第二范式、第三范式和第四范式

### 函数依赖

x->y称为x决定y，或y依赖于x，x称为决定因素

函数依赖与其他依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖

完全函数依赖与部分函数依赖：

> 完全函数依赖：
>
> 对于x任意一个真子集都无法决定y
>
> x-F> y

不完全函数依赖则为部分函数依赖

传递函数依赖

> 传递函数依赖：
>
> x->y,y-传递>z;x->z

### 码

```
若K---F>-U

则K为R的候选码

若K-->U

则K称为超码
```

当候选码多于一个，就选一个作为主码

包含在任意一个候选码中的属性称为主属性

不包含在任意候选码中的属性称为非主属性

整个属性组全为码，称为全码

在关系模式中，码会用下划线显示

### 范式

关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式

满足最低要求的称为第一范式，简称1NF

在第一范式中满足进一步要求的为第二范式，以此类推

>  一个低一级范式的关系模式通过模式分解，可以转换为若干个
>
> 高一级范式的关系模式的集合
>
> 这个过程，称为规范化

### 2NF

当满足第一范式且，每一个非主属性完全依赖于任何一个候选码，就为2NF

即

候选码--F>>--非主属性

### 3NF

当满足第二范式，且每一个非主属性既不传递依赖于码，也不部分依赖于码

### BCNF

修正的3NF，扩充的第三范式

> 所有非主属性对每一个码都是完全函数依赖
>
> 所有主属性对每一恶搞不包含它的码也是完全函数依赖
>
> 没有任何属性完全函数依赖于非码的任何一组属性

### 多值依赖

有A,B,C三个实体

每一个A中每一个值a,在B中有一个完整的集合对应（即一对多的关系），即A➡️➡️B.而与C的取值无关

MSC(M,S,C)中，M表示专业，S表示学生，C表示该专业必修课，假设每个专业有多个学生，有一组必修课，设同专业内所有学生选修的必修课相同。

实例如下，按照语义对于M的每一个值M，S有一个完整的集合对应，而不问C取何值，所以M→→S，由于C与S的完全对称性，必然有M→→C成立。

　　M　　　　　　S　　　　　　C

　　M1　　　　　 S1　　　　　 C1

　　M1　　　　　 S1　　　　　 C2

　　M1　　　　　 S2　　　　　 C1

　　M1　　　　　 S2　　　　　 C2

多值依赖的性质：

1.对称性：A→→B,B→→A

2.传递性,A→→B,B→→C,A→→C

3.函数依赖可以看成是多值依赖的特殊情况

### 4NF

如果满足第一范式，且对于每个多值依赖，A→→B,A都含有码，则称满足第四范式

### 规范化小结

规范化的基本思想是逐步消除数据依赖中的不合适的部分

让模式中的各关系模式达到某种程度的分离，即一事一地的模式设计原则

让一个关系描述一个概念、一个实体或实体间的一种联系

若多于一个概念就“分离”出去

因此所谓规范化实质上是概念的单一化

| 1NF  |                 分量不可再分                 |
| :--: | :------------------------------------------: |
| 2NF  | 消除非主属性对码的部分依赖（保证是完全依赖） |
| 3NF  |          消除非主属性对码的传递依赖          |
| BCNF |        消除主属性对码的部分和传递依赖        |
| 4NF  |       消除非平凡属性且非函数的多值依赖       |

关系模式的过程化是通过对关系模式对分解来实现的

即把低一级的关系模式分解为若干个高一级别的关系模式

## 数据依赖的公理系统

数据依赖的公理系统是模式分解的理论基础

```
逻辑蕴含：
任意一个关系，函数依赖X→Y都成立
则称F逻辑蕴含
```

> Armstrong公理系统：自反律，增广律，传递律:

- 自反率：若Y是X的一部分（子集），则X→Y
- 增广率：如果X→Y，则XZ→YZ（X∪Z→Y∪Z）
- 传递率：如果X→Y，Y→Z，则X→Z

推理

- 合并规则：若X→Y，X→Z，则X→YZ
- 伪传递规则：若X→Y，WY→Z，则XW→Z
- 分解性规则：若X→Y，Z是Y的一部分（子集），则X→Z

Armstrong公理系统是有效的、完备的

闭包：

F所逻辑蕴含的函数依赖的全体叫F的闭包

## 模式的分解

### 模式分解的三个定义

分解具有无损连接性

分解要保持函数依赖

分解既要保持函数依赖，又要具有无损连接性

### 分解的无损连接性和保持函数依赖性

### 模式分解的函数

# 七、数据库设计

## 数据库设计概述

数据库设计，狭义地说，

是设计数据本身，即设计数据库的各级模式并建立数据库

这是数据库应用设计的一部分

> 数据库的一般定义：
>
> 数据库设计是指对于一个给的的应用环境，构造设计优化的数据库逻辑模式和物理结构
>
> 并据此建立数据库及其应用系统，使之能够有效的存储和管理数据
>
> 满足各种用户的需求，包括信息管理要求和数据操作要求

### 数据库设计的特点

#### 数据库建设的基本规律

“三分技术，七分管理，十二分基础数据”是数据库设计的特点之一

#### （结构）数据设计和行为（处理）设计相结合

数据库设计应该和应用系统设计相结合，这是数据库设计的第二个特点

即结合结构特性和行为特性

### 数据库设计的方法

新奥尔良方法

基于E-R模型的设计方法

3NF的设计方法

面向对象的数据库设计方法

统一建模方法

### 数据库设计的基本步骤

按照结构化系统设计的方法，考虑数据库及应用系统开发全过程

将数据库设计分为6个阶段：

1.需求分析阶段

2.概念结构设计阶段

​		使整个数据库设计的关键

3.逻辑结构设计阶段

​		将概念结构转换为数据模型

4.物理结构设计阶段

​		将逻辑结构转换为物理结构（存储方法和存储结构）

5.数据库实施阶段

6.数据库运行和维护阶段

|     设计阶段     |                  设计描述                  |
| :--------------: | :----------------------------------------: |
|   需求分析阶段   | 数字字典、数据结构、数据流、数据存储的描述 |
|   概念结构设计   |        概念模型——（E-R图)，数据字典        |
|   逻辑结构设计   |           某种数据模型--关系模型           |
|   物理结构设计   |    存储安排、存储方法选择、存取路径选择    |
|    数据库实施    |   创建数据库模式，装入数据，数据库试运行   |
| 数据库运行和维护 |         性能检测、数据库重组和重构         |



### 数据库设计过程中的各级模式

|   设计阶段   |      各级模型      |
| :----------: | :----------------: |
| 需求分析阶段 |                    |
| 概念结构设计 |      概念模式      |
| 逻辑结构设计 | 逻辑模式（外模式） |
| 物理结构设计 |       内模式       |



## 需求分析

### 需求分析的任务

需求分析的任务是明确用户的各种需求，然后在此基础上确定系统的功能

调查的重点是“数据”和“处理”，通过调查、收集与分析，获取用户对数据库的如下要求：

信息要求

处理要求

安全性与完整性要求

### 需求分析的方法

进行需求分析首先是调查用户的实际要求，与用户达成共识，然后分析与表达这些要求

### 数据字典

数据字典上关于数据库中数据的描述，即元数据，不是数据本身

数据字典在需求分析阶段建立

在数据库设计过程中不断修改、充实、完善

通常包括数据项、数据结构、数据流、数据存储和处理几个部分

#### 数据项

数据项是不可再分的数据单位

数据项描述={数据项名，数据项含义说明，别名，数据类型，长度，取值范围，

​								取值含义，与其他数据项的逻辑关系，数据项之间的关系}

#### 数据结构

数据结构反映了数据之间的组合关系

数据结构描述={数据结构名，含义说明，组成：{数据项获数据结构}}

#### 数据流

数据流是数据结构在系统内传输的路径

数据流描述={数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}

#### 数据存储

数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一

数据存储描述={数据存储名，说明，编号，输入的数据流，输出的数据流，

​								组成：{数据结构}，数据量，存取频度，存取方式}

#### 处理过程

处理过程的具体处理逻辑一般用判定表货判断树来描述

处理过程描述：={处理过程名，说明，输入：{数据量}，输出：{数据流},处理:{简要说明}}

## 概念结构设计

将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计

是整个数据库设计的关键

### 概念模型

概念模式是各种数据模型的共同基础，比数据模型更加独立于机器、更抽象，从而更稳定

描述概念模型的有力工具是E-R模型

### E-R模型

P.P.S.Chen提出的E-R模型是用E-R图来描述现实世界的概念模型

包括实体、属性、实体之间的联系

#### 实体之间的联系

实体之间的联系通常是指不同实体型的实体集之间的联系

1. 两个实体型之间的联系

   一对一（1  1）

   一对多（1  n）

   多对多(m  n)

2. 两个以上实体型之间的联系

   也包括一对一，一对多，多对多

3. 单个实体型内的联系

   也包括一对一，一对多，多对多

> 一般地，把参与联系的实体型的数目称为度
>
> 两个实体型之间的联系度为2，也成二元联系
>
> 三个实体型之间的联系度为3，称为三元联系
>
> N个实体型之间的联系度为N，也称为N元联系

#### E-R图

E-R图提供了描述实体、属性、和联系度方法

1. 视图用矩形表示
2. 属性用椭圆表示
3. 联系用菱形表示



### 概念结构设计

概念结构设计的定义一步就是对需求分析阶段收集到的数据进行分类、组织，确定实体、实体的属性、实体之间的联系类型，形成E-R图

#### 实体和属性的划分原则

1.属性是不可再分的数据项，不能包含其他属性

2.属性不能与其他实体具有联系

#### E-R图的集成

首先设计各子系统的E-R图，

然后将它们集成起来，得到全局的E-R图

E-R图的集成分两步走：

1. 合并

   解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图

   消除冲突：属性冲突、命名冲突、结构冲突

2. 修改和重构

   消除不必要的冗余，生成基本的E-R图

## 逻辑结构设计

逻辑结构设计的任务是把概念结构设计好的基本E-R图转换为与选用数据库系统产品所支持的数据模型相符合的逻辑结构

### E-R图向关系模型的转换

E-R图向关系模型的转换要解决的问题是

如何将实体型和实体之间的联系转换为关系模式，如何确定这些关系模式的属性和码

转换的一般原则：

> 一个实体型转换为一个关系模式
>
> 三个或三个以上实体间的联系转换为一个关系模式
>
> 具有相同码的关系模式可合并
>
> 一对一和一对多的联系可与n端对应的关系模式合并
>
> 多对多的联系转换为一个关系模式

### 数据模型的优化

数据逻辑结构的设计不是唯一的

也并不是规范化程度越高关系就越优

### 设计用户子模式

将概念模型转换为全局逻辑模型后，还应该更加用户的局部应用需求，结合具体具体关系数据库管理的特点设计用户的外模式

目前关系数据库管理系统一般都提供了视图概念，可以利用这一功能设计更符合局部用户需要的用户外模型

1.使用更符合用户习惯的别名

2.可以对不同级别的用户定义不同的视图，以保证系统的安全性

3.简化用户对系统的使用

## 物理结构设计

为一个给的逻辑数据模型选取一个最合适应用要求的物理结构的过程，就是数据库的物理设计

通常分为两步：

1.确定数据库的物理结构

​	在关系数据库中主要指存取方法和存储结构

2.对物理结构进行评价

### 数据库物理设计的内容和方法

关系数据库数据库物理设计的内容包括：

为关系模式选择存取方法，以及设计关系、索引等数据库文件等物理存储结构

### 关系模式存取方法选择

存取方法是快速存取数据库中数据的技术

通常包括索引方法和聚簇方法

#### B+树索引

#### hash索引

#### 聚簇

把属性具有相同之的元组存放在连续的物理块中，称为聚簇，该属性（组）称为聚簇码

### 确定数据库的存储结构

确定数据库物理结构主要指确定数据的存放位置和存储结构，包括确定关系、索引、聚簇、日志、备份等等存储安排和存储结构，确定系统配置等

##### 确定数据的存放位置

根据应用情况，将数据的易变部分与稳定部分、经常存取部分和存取频率较低部分分开存放

##### 确定系统配置

重新对系统配置变量和存储分配参数进行赋值

#### 评价物理结构

时间效率、空间效率、维护代价和各种用户要求进行平衡

## 数据库的实施和维护

把数据库逻辑设计和物理设计结果在数据库管理系统中描述出来

称为数据库管理系统可以接受的代码，再经过调试产生目标模式

然后就可以组织数据入库

这就是数据库的实施阶段

### 数据的载入和应用程序的调试

数据库实施阶段包括两项重要的工作，一项是数据的载入，一项是应用程序的编码和调试

数据库应用程序的设计应该和数据库设计同时进行

### 数据库的试运行

1.先输入小批数据做测试，待试运行基本合格后再大批输入数据，逐步增加数据量，逐步完成运行评价

2.要做好数据库存储和恢复工作

### 数据库的运行和维护

数据库的维护工作主要包括以下几个方面：

#### 数据库的转储和恢复

#### 数据库的安全性、完整性控制

#### 数据库性能的监督、分析和改造

#### 数据库的重组织和重构造

# 八、数据库编程

在应用系统中如何使用编程方法对数据库进行操作的技术

SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足，提高应用系统和数据库管理系统间的互操作性

在应用系统中使用SQL编程来访问和管理数据库中数据的主要方法有：

嵌入式SQL、过程化SQL、存储过程和自定义函数、

开放数据库互联、Java数据库连接等编程方式

## 嵌入式SQL

SQL的特点之一是在交互式和嵌入式两种不同的使用方式下，SQL的语法结构上基本一致的

### 嵌入式SQL的处理过程

嵌入式SQL上将SQL嵌入到程序设计语言中

被嵌入的程序设计语言称为主语言如C,C++,Java

对嵌入式SQL语言，数据库管理系统一般采用预编译方法处理

即由数据库管理的预处理程序对源处理程序进行扫描，识别出嵌入式SQL语句

把它们转换成主语言调用语句

以使主语言编译程序能识别它们，然后由主语言的预编译程序将纯的主语言程序编译成目标码

为了与主语言进行区分，必须加SQL前缀：



```
C:
EXEC SQL<SQL语句>;

JAVA:
#SQL<SQL语句>
```



### 嵌入式SQL语句与主语言之间的通信

数据库工作单元和源程序工作单元之间的通信主要包括：

1.向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程

2.主语言向SQL语句提供参数，主要用主变量实现

3.将SQL语句查询数据库的结果交主语言处理，主要用主变量和游标实现（cursor)

#### SQL通信区

SQL语句执行后，系统把反馈信息送到SQL通信区中，应用程序从SQL通信区中取出这些状态信息，据此决定接下来执行的语句

SQL通信区在应用程序中以下语句定义

```sql
EXEC SQL INCLUDE SQLCA
```

SQL通信区中有一个变量SQLCODE，用来存储每次执行SQL语句后返回的代码



#### 主变量

SQL语句中使用的主语言程序变量称为主变量

分为输入主变量和输出主变量

输入主变量：由应用程序对其赋值，SQL语句调用

输出主变量由SQL语句对其赋值状态信息，返回给应用程序

#### 游标

游标是系统为用户开设的一个数据缓冲区

用来存放SQL语句的执行结果，每个游标区都有一个名字

用户可以通过游标逐一获取记录并赋值给主变量，交由主变量进一步处理

#### 建立和关闭数据库连接

1.建立数据库连接

​	

```sql
EXEC SQL CONNECT TO target[AS connection-name][USER user-name]
/*
target是要连接的数据库服务器
*/
```

2.关闭数据库连接

```sql
ECEC SQL DISNENNECT[connection];
```



### 不用游标的SQL语句

有的SQL语句需要使用游标

#### 查询结果为单记录的SELECT语句

#### 非CURRENT形式的增删改语句

### 使用游标的SQL语句

#### 查询结果为对条记录的SELECT语句

#### CURRENT形式的 UPDATE和 DELETE语句

### 动态SQL

有些应用可能要到执行时才能够确定要提交的SQL语句、查询的条件，此时就要使用动态的SQL语句

#### 使用SQL语句主变量

查询变量包含的内容时SQL语句的内容，称为SQL语句主变量

SQL语句主变量可以在程序执行期间设定不同的SQL语句，然后执行

#### 动态参数

动态参数是SQL语句中的可变元素，使用“？”表示该位置的数据在运行时设定

动态参数的输入是通过PREPARE语句准备主变量和执行语句EXECUTE绑定数据或主变量来完成

使用动态参数的步骤：

1.声明SQL语句主变量

2.准备SQL语句（PREPARE）

#### 执行准备好的语句（EXECUTE）

EXECUTE将SQL语句中分析出的动态参数和主变量或数据常量绑定，作为语句的输入或输出

```sql
EXEC SQL EXECUTE<语句名>[INTO<主变量表>][USING<变量>];
```



## 过程化SQL

SQL可以使用程序设计语言来定义过程和函数

也可以用关系数据库管理系统自己的过程语言来定义

### 过程化SQL的块结构

基本的SQL时高度非过出化的语言

过程化SQL时对SQL的拓展，使其增加了过程化语句功能

过程化SQL程序的基本结构是块

所有的过程化SQL都是由块组成，这些块之间可以相互嵌套，每个块完成一个逻辑功能

主要有两种类型

命名块和匿名块，下面的是匿名块，每次执行时都要进行编译

过程和函数时命名块，被编译后保存到数据库中，称为持久性存储模块

### 变量和常量的定义

变量的定义

```sql
变量名 数据类型 [NOT NULL]:=初值表达式
```

常量的定义

```sql
常量名  数据类型 CONSTANT:=常量表达式
```

赋值语句

```
变量名:=表达式
```



### 流程控制

### 条件控制语句

IF

IF -THEN

IF 嵌套

### 循环控制语句

LOOP

WHILE-LOOP

FOR-LOOP

### 错误处理

出现了错误，就停下来根据异常的类型去处理错误

## 存储过程和函数

主要是命名模块

存储过程是由过程化SQL语句书写的过程，这个过程经过编译和优化后存储在数据库服务器中，因此称为存储过程，使用时直接调用即可

### 存储过程

#### 存储过程的优点

1.运行效率高

2.存储过程降低了客户机和服务器之间的通信量

3.方便实施企业规则

#### 存储过程的用户接口

用户可通过SQL语句创建、执行、修改和删除存储过程

### 函数

自定义函数，有用户自己使用过程化SQL设计定义

函数和存储过程类似，也是永久性存储模块

必须指定返回的类型

#### 函数的定义语句格式

```sql
CREATE OR REPLACE FUNCTION 函数吗（参数）RETURNS<类型> AS <过程化SQL块>
```



### 函数的执行语句格式

```sql
CALL/SELECT 函数名（参数列表）
```



#### 修改函数

```sql
ALTER FUNCTION 过程1 RENAME 过程2
ALTER FUNCTION 函数名 COMPILE;
```



### 过程化的SQL中的游标

当查询返回多条记录时，就要使用游标对结果集进行处理

一个游标与一个SQL语句相关联

在存储过程中可以定义普通游标、REFCURSOR类型游标、带参数的游标等

## ODBC编程

使用ODBC来进行应用程序等设计

使用ODBC编写的应用程序可以移植性好，能同时访问多个不同的数据库，共享多个数据资源

### ODBC概述

ODBC是微软推出的接口标准，使数据库系统“开放”，能够实现“数据库互联”

并提供了一组访问数据库的应用程序编程接口（API）

ODBC一方面规范应用开发，一方面规范关系数据库管理系统应用接口

### ODBC工作原理概述

ODBC应用系统的体系由4部分组成：

用户应用程序、ODBC驱动程序管理器

数据库驱动程序、数据源

####  用户应用程序

用户应用程序包括提供用户界面、应用逻辑和事物逻辑

使用ODBC开发数据库应用程序时，应用程序调用的是标准的ODBC函数和SQL语句

应用程序使用ODBC API调用接口与数据库进行交互

使用ODBC来开发应用程序的程序称为ODBC应用程序

#### ODBC驱动程序管理器

驱动程序管理器原来管理各种驱动程序

ODBC驱动程序管理器由微软提供

ODBC驱动程序管理器可以建立、配置或删除数据源，并查看系统当前安装的数据库ODBC驱动程序

#### 数据库驱动程序

ODBC通过数据库驱动程序来提供应用系统与数据平台的独立性

ODBC应用程序不能直接存取数据库，其各种操作请求由驱动程序管理器提交给某个关系数据库管理系统的ODBC驱动程序

#### ODBC数据源管理

数据源是最终用户需要访问的的数据，包含了数据库位置和数据中类型等信息

实际上是一种数据连接等抽象

ODBC给每个被访问的数据源指定唯一的数据源名，并映射到所有必要的、用来存取数据的底层软件

### ODBC API基础

各个数据库厂商的ODBC应用程序编程接口（ODBC API）都要符合两方面的一致性：

API一致性

语法一致性

#### 函数概述

ODBC提供了76个函数接口

#### 句柄及其属性

句柄是32位整数值，代表一个指针

#### 数据类型

ODBC定义了两套数据类型，即SQL数据类型和C数据类型

SQL数据类型用于数据源，C数据类型用于应用程序的C代码

### ODBC的工作流程

#### 1.配置数据源

#### 2.初始化环境

#### 3.建立连接

#### 4.分配句柄

##### 5.执行SQL语句

#### 6.结果集处理

#### 7.终止处理



# 九、关系查询和查询优化

## 关系数据库系统的查询处理

查询处理树关系数据库系统执行查询语句的过程

其任务是把用户提交给关系数据库系统的查询语句转换为高效的查询执行计划

## 查询处理步骤

#### 1.查询分析

进行扫描，进行词法检查和语法检查

#### 2.查询检查

进行语义检查

这是的完整性检查时初步的、静态的检查

检查通过后便把SQL查询语句转换成内部表示，即等价的关系代数表达式

关系数据管理系统一般有检查树，也称语法分析树来表示拓展的关系代数表达式

#### 3.查询优化

分为代数优化和物理优化

#### 4.查询执行

依据优化器得到的执行策略生成查询执行计划，有代码生成器生成执行这个查询计划的代码，

然后执行，返回查询结果



## 关系数据库系统的查询优化

关系查询优化是影响关系数据库管理系统系能关键因素

### 查询优化概述

关系系统的查询优化既是关系数据库管理系统的关键技术，又是关系系统的优点所在

查询优化的优点不仅在于优化不必考虑如何最好的表达查询以获得较高的效率，而且在于系统可以比优化程序“优化”做得好

查询执行开销主要包括

磁盘存取块数（I/O代价）、处理机时间（CPU）代价以及查询的内存开销

在计算查询代价时一般用查询处理读写的块数作为衡量标准



# 十、数据库恢复技术

## 事务的基本概念

### 事务

所谓事务

十一还有定义的一个数据库操作序列

这些操作要么全做，要么全不做，是一个不可分割的工作单位

### 事务的ACID特性

原子性

一致性

隔离性

持续性（永久性）

## 数据库恢复概述

把数据库从错误状态恢复到某一一只的正确状态的功能，就是数据库的恢复功能

## 故障的种类

### 事务内部的故障

事务内部的故障时非预期的，不能由应用程序处理的

事务内部的故障仅指非预期的

这类恢复称为事务撤销(UNDO)

### 系统故障

称为软故障

系统故障时造成系统停止运转的任何时间，是的系统要重新启动

还需要重做（REDO）

### 介质故障

介质故障称为硬故障

### 计算机病毒

## 恢复的实现技术

恢复机制设计的两个关键问题是：

如何建立冗余数据

如何利用这些冗余数据实施数据库恢复

建立冗余数据常用的技术是

数据转储和登记日志文件

### 数据转储

转储即数据库管理员定期地将整个数据库复制到磁盘、磁盘或其他存储介质上保存起来的过程

静态转储是在系统中无运行事务时的转储操作

动态转储时转储期间允许对数据库进行存取或修改

数据转储方法可分为：

动态海里转储、动态增量转储、静态海量转储和静态增量转储

### 登录日志文件

### 日志文件的格式和内容

日志文件是用来记录事务对数据库的共享操作的文件

日志文件中需要登记的内容包括：

> 各个事务的开始
>
> 各个事务的结束
>
> 各个事务的所有关系操作

每个日志记录的内容主要有：

> 事务标记
>
> 操作的类型
>
> 操作对象
>
> 更新前数据的旧值
>
> 更新后数据的新值

### 日志文件的作用

1.事务故障恢复和系统故障恢复必须要用日志文件

2.在动态存储方式在必须建立日志文件，后备副本和日志文件结合起来才能有效的恢复数据库

3.静态转储方式中，也可以建立日志文件

### 登录日志文件

为保证数据库是可恢复的，登录日志文件应该遵循两条准则：

> 登记的次序严格按并发事务执行的时间次序
>
> 必须献血日志文件，后写数据库

## 恢复策略

###  事务故障的恢复

1.反响扫描日志文件，查找该事务的更新操作

2.对改事务执行逆操作

3.继续反向扫描日志文件，查找该事务的其他操作，做同样处理

4.如此循环

### 系统故障的恢复

1.正向扫描日志文件，找出故障前提交的事务，并将其记如重做队列，

​	同时找出故障发生时未完成的事务，将其记入撤销队列

2.对撤销队列中的各个事务进行撤销操作

3.对重做队列中的各个事务进行重做处理

### 介质故障的恢复

重装数据库，然后重做已完成的事务

## 具有检查点的恢复技术

检查点记录---增加一个重新开始文件，并让恢复子系统在登录日志文件期间动态地维护日志

检查点的日志记录包括：

> 建立检查点时刻所有正在执行的事务清单
>
> 这些事务最近一个日志记录的地址

动态维护日志文件的方法是：

周期性地执行检查点、保存数据库状态的操作

使用检查点可以改善恢复效率

系统使用检查点方法进行恢复的步骤是：

1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址

​	由改该地址在日志文件中找到最后一个检查点文件

2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST

3.从检查点开始正向扫描日志文件

4.对undo-list执行undo操作，redo-list执行redo操作

## 数据库镜像

数据库镜像功能用于数据库恢复

即根据数据库管理员的要求

自动把整个数据库或其中的关键数据复制到另一个磁盘上

每当数据库更新时，数据库管理自动把更新后的数据复制过去

由数据库管理系统自动保证镜像数据与主数据的一致性

# 十一、并发控制

事务可以一个一个串行执行，即每个时刻只有一个事务运行

在单处理机系统中，事务的并发执行实际上是这些并发事务的并发操作轮流交叉运行

## 并发控制概述

事务是并发控制的基本单位

为了保证事务的隔离性和一致性

数据库管理系统需要对并发操作进行正确调度

并发操作带来的数据不一致性包括

丢失修改、不可重复度和读“脏”数据

### 丢失修改

修改被丢失

### 不可重复读

无法再现前一次读取结果

### 读“脏”数据

读“脏”数据是指读到的是不正确的数据

---

并发控制机制就是要用正确的方式调度并发操作

使一个用户事务执行不必受到其他事物的干扰

并发控制技术主要有：

封锁

时间戳

乐观控制法

多版本并发控制

## 封锁

封锁是实现并发控制的一个重要技术

基本的锁类型有两种：

排他锁和共享锁

### 排他锁（X锁)

又称写锁

### 共享锁(S锁)

又称读锁

## 封锁协议

加锁时，需要约定的规则：

称为封锁协议

### 一级封锁协议

事务进行修改数据前必须先对其加X锁，知道事务结束才释放

### 二级封锁协议

在一级封锁协议基础上增加：

读取数据前必须先对其加S锁，读完后才释放

### 三级封锁协议

在一级锁基础上增加：

读取数据前必须加S锁，知道事务结束才释放

## 活锁与死锁

### 活锁

活锁：某一事务永远等待

解决办法是：采用先来先服务的策略

### 死锁

死锁：两个事务永远不能结束

#### 死锁的预防

一次封锁发

顺序封锁法

#### 死锁的诊断与解除

超时法

事务等待图发

## 并发调度的可串行性

数据库管理系统对并发事务的不同调度会产生不同的结果

显然，串行调度锁可行的

执行结果等价于串行的调度的调度，这也是正确的

这样的调度称为串行化调度

### 可串行化调度

可串行化调度：

> 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行的结果相同
>
> 这种调度策略称为可串行化调度

可串行化调度是并发事务正确调度的准则

### 冲突与串行化调度

冲突操作是指不同的事务对同一个数据的读写操作和写写操作

判断可串行化调度的成分条件：

若一个调度的冲突是可串行化，则一定是可串行化的调度

> 冲突时可串行化调度的成分条件

## 两端锁协议

两端锁协议是指：

对所有事务必须分两个阶段对数据项加锁和解密

第一个阶段：

获得封锁，也称为拓展阶段

第二个阶段：

释放封锁，也称为收缩阶段

> 事务遵循两锁也是可串行化的充分条件，而不是必要条件

## 封锁的粒度

封锁对象的大小称为封锁粒度

封锁对象可以是一些逻辑单元，也可以是一些物理单元

封锁粒度与系统的开发度和并发控制的开销密切相关

### 多粒度封锁

多粒度封锁定义：

在一个系统中同时支持多种封锁粒度供不同的事务选择

多粒度树：按粒度大小划分节点，根节点上整个数据库

多粒度封锁协议：

允许多粒度树中的每个节点被独立地加锁

对一个结点加锁，意味着后代结点也会被加上同类型的锁

显式封锁：

​	显式封锁是应事务的要求直接拿到数据对象上的锁

隐式封锁：

​	隐式封锁是对数据对象没有被独立加锁，是由于其上级结点加锁而被加上的锁

### 意向锁

意向锁的定义：

> 如果对一个结点加意向锁，则说明改结点的下层结点正在被加锁；
>
> 对任意结点加锁时，必须先对它的上级结点加锁

分为意向共享锁(IS)、意向排他锁(IX)和共享意向排他锁(SIX)

## 其他并发控制

时间戳方法：

时间戳给每一个事务盖上一个时标，并按照这个时间戳来解决事务的冲突操作

乐观控制方法（验证方法）

### 多版本并发控制

版本是指数据库中数据对象的一个快照，记录了数据对象某个时刻的状态

多版本控制和封锁控制相比

主要的好处是消除了数据库对象读和写操作的冲突，有效的提高了系统的性能

### 改进的多版本控制

引进验证锁
